# -*- coding: utf-8 -*-
"""Enopolis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PBR96YzX30fqT8LwzficNymXEL0K3lCo
"""


from sklearn.neighbors import NearestNeighbors

import numpy as np
import random
from tensorflow.keras.models import Model, Sequential, load_model  # Импортируем модели keras: Model
from tensorflow.keras.layers import Input, Conv2DTranspose, concatenate, Dropout, Activation, Flatten, SpatialDropout2D, MaxPooling2D, \
    AveragePooling2D, Conv2D, Dense, LSTM, GRU, BatchNormalization, Reshape, Conv1D, MaxPooling1D  # Импортируем стандартные слои keras
from tensorflow.keras import backend as K  # Импортируем модуль backend keras'а
from tensorflow.keras.optimizers import Adam, RMSprop  # Импортируем оптимизатор Adam
from tensorflow.keras import \
    utils  # Импортируем модуль utils библиотеки tensorflow.keras для получения OHE-представления
from keras import regularizers
from keras.callbacks import Callback
import tensorflow as tf
import os
from tqdm.auto import tqdm
import glob

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from keras import backend as K
from tensorflow.keras.initializers import GlorotUniform, Orthogonal

import warnings
warnings.filterwarnings("ignore")

Colab = True
try:
    from google.colab import drive
except:
    Colab = False

if Colab:
    from google.colab import drive

    # Подключаем Google drive
    drive.mount('/content/drive')
    CrPath = "/content/drive/MyDrive/Uinnopolis/"

    import sys
    sys.path.append('/content/drive/MyDrive/Uinnopolis')
else:
    Acer = not os.path.exists("E:/Uinnopolis/")
    CrPath = "C:/Uinnopolis/" if Acer else "E:/Uinnopolis/"

from Libs import * #ReadCsv, WriteCsv, Graphic, Filter
from Experiments import *
from NN import *

os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'
tf.get_logger().setLevel('ERROR')

random.seed(1)

print('Reading Dataset')
X, Y = ReadCsv(CrPath, DelZeros = True, SortCtg = False, Train = True, Au = True)
XTest, YTest = ReadCsv(CrPath, DelZeros = True, SortCtg = True, Train = False, Au = True)
Data = (X, Y, XTest, YTest)
print(Y.shape)
X_train, X_test, y_train, y_test = train_test_split(X, Y[:, 1:2], test_size=0.03, random_state=42)
print(y_train.shape, y_test.shape)
X_train, y_train = TimeAugmentation(X_train, y_train, K=30, random=1, LevelK=0.2)
print(X_train.shape, y_train.shape)

Inp = Input(shape=(X_train.shape[-1], 1))
InpDense = Reshape((X_train.shape[-1],))(Inp)
X = Conv1D(filters = 50,
           kernel_size = 7,
           strides=1,
           padding="same")(Inp)

X = MaxPooling1D(pool_size=2, strides=2, padding="same")(X)
if True: # будет проброс
    X = GRU(50, return_sequences=False,
      kernel_initializer=GlorotUniform(seed=1),
      recurrent_initializer=Orthogonal(seed=2))(X)
    X = concatenate([X, InpDense])
else:
    X = GRU(50, return_sequences=True,
            kernel_initializer=GlorotUniform(seed=1),
            recurrent_initializer=Orthogonal(seed=2))(X)

    model.add(Flatten())

X = Dense(7, activation="softmax", kernel_initializer=GlorotUniform(seed=6))(X)
model = Model(inputs=Inp, outputs=X)
model.compile(loss='categorical_crossentropy', optimizer=RMSprop(lr=0.002), metrics=['accuracy'])
model.summary()
History = model.fit(X_train.reshape( (X_train.shape[0], X_train.shape[1], 1) ), to_categorical(y_train),
                    validation_data = (X_test.reshape( (X_test.shape[0], X_test.shape[1], 1 )), to_categorical(y_test)),
                    epochs = 50,batch_size = 128, verbose = 1)



def GRUModel(XShape, N):
    random.seed(0)
    Inp = Input(shape=(XShape[-1]))



    Den = Dense(N, input_shape=(XShape[-1],), activation="relu",
                kernel_initializer=GlorotUniform(seed=1))(Inp)
    Den = Dropout(0.25)(Den)
    #
    #XLSTM = BatchNormalization()(XLSTM)
    #XLSTM = GRU(100, return_sequences=True)(XLSTM)
    #InpDense = Reshape((XShape[-1],))(Inp)
    Den = Dense(N//4, activation="relu", kernel_initializer=GlorotUniform(seed=3))(Den)
    #XDENSE = concatenate([XLSTM, InpDense])

    Den = Dense(N//8, activation="relu", kernel_initializer=GlorotUniform(seed=4))(Den)
    Den = Dropout(0.25)(Den)

    Den = Dense(N//16, activation="relu", kernel_initializer=GlorotUniform(seed=5))(Den)
    Den = Dropout(0.25)(Den)
    Den = Dense(7, activation="softmax", kernel_initializer=GlorotUniform(seed=6))(Den)

    model = Model(inputs=Inp, outputs=Den)

    model.compile(loss='categorical_crossentropy', optimizer=RMSprop(lr=0.002), metrics=['accuracy'])
    model.summary()
    print(N)
    return model


for i in range(20):
    model_checkpoint_callback = ModelCheckpoint(
        filepath=f'{CrPath}Dense{1000 + (i * 100)}.h5',
        save_weights_only=False,
        monitor='val_accuracy',
        mode='max',
        verbose = 1,
        save_best_only=True)

    model_checkpoint_loss_callback = ModelCheckpoint(
        filepath=f'{CrPath}DenseL{1000 + (i * 100)}.h5',
        save_weights_only=False,
        monitor='val_loss',
        mode='min',
        verbose=1,
        save_best_only=True)

    M = GRUModel(X_train.shape, 1000 + (i * 100))
    History = M.fit(X_train, to_categorical(y_train), validation_data = (X_test, to_categorical(y_test)), epochs = 50, 
              batch_size = 128, verbose = 1, callbacks = [model_checkpoint_callback, model_checkpoint_loss_callback])
    
    M = load_model(f'{CrPath}Dense{1000 + (i * 100)}.h5')
    y_pred = M.predict(XTest)

    WriteCsv(fr'{CrPath}Dense{1000 + (i * 100)}.csv', YTest[:,1], np.argmax(y_pred, -1))

    M = load_model(f'{CrPath}DenseL{1000 + (i * 100)}.h5')
    y_pred = M.predict(XTest)

    WriteCsv(fr'{CrPath}DenseL{1000 + (i * 100)}.csv', YTest[:, 1], np.argmax(y_pred, -1))

    plt.figure(figsize=(14, 7))

    if 'val_accuracy' in History.history:
        plt.plot(History.history['val_accuracy'],
              label='Доля верных ответов на тестовом наборе')
    plt.plot(History.history['accuracy'],
              label='Доля верных ответов на тренировочном наборе')
    plt.xlabel('Эпоха обучения')
    plt.ylabel('Доля верных ответов')
    plt.legend()
    plt.show()

K.set_value(model.optimizer.learning_rate, 0.0001)

M = load_model(f'{CrPath}GRU0.h5')
y_pred = M.predict(XTest)

WriteCsv(fr'{CrPath}GRU0.csv', YTest[:,1], np.argmax(y_pred, -1))

from sktime.classification.kernel_based import RocketClassifier
from Libs import * #ReadCsv, WriteCsv, Graphic, Filter
from Experiments import *
from NN import *



X, Y = ReadCsv(CrPath, DelZeros = True, SortCtg = False, Train = True, RetPrc = True)
XTest, YTest = ReadCsv(CrPath, DelZeros = True, SortCtg = True, Train = False, Au = True)

X_train, X_test, y_train, y_test = train_test_split(X, Y[:, 1], test_size=0.1, random_state=42)

rocket = RocketClassifier()
rocket.fit(X_train, y_train)
y_pred = rocket.predict(X_test)
print(recall_score(y_test, y_pred, average="macro", zero_division=0))
print(0, classification_report(y_pred, y_test))

from sktime.classification.hybrid import HIVECOTEV2
hc2 = HIVECOTEV2(time_limit_in_minutes=1, random_state = 0)
hc2.fit(X_train, y_train)
y_pred = hc2.predict(X_test)
print(recall_score(y_test, y_pred, average="macro", zero_division=0))
print(0, classification_report(y_pred, y_test))
WriteCsv(fr'{CrPath}HV.csv', y_test, y_pred)

X_train, y_train = TimeAugmentation(X_train, y_train, K=10, random=1, LevelK=0.1, Ver = 0, SinMode = False)

from sklearn.ensemble import RandomForestClassifier

from sktime.pipeline import make_pipeline
from sktime.transformations.panel.tsfresh import TSFreshFeatureExtractor

tsfresh_trafo = TSFreshFeatureExtractor(default_fc_parameters="minimal")
randf = RandomForestClassifier(n_estimators=175)
pipe = make_pipeline(tsfresh_trafo, randf)

pipe.fit(X_train, y_train)
y_pred = pipe.predict (X_test)
accuracy_score (y_test, y_pred)

print(recall_score(y_test, y_pred, average="macro", zero_division=0))
print(0, classification_report(y_pred, y_test))
WriteCsv(fr'{CrPath}pipe.csv', y_test[:, 1:2], y_pred)

neigh = NearestNeighbors(n_neighbors=10, metric='cosine')
neigh.fit(X)

distances, idxs = neigh.kneighbors(queries_embeddings, 10, return_distance=True)

"""loss: 0.0515 - accuracy: 0.9840 - val_loss: 0.7139 - val_accuracy: 0.8390


"""





CrModel =  LSTMModel(LSTMLayers = [150], DenseLayers = [150], Epochs=30, Batch_size=128)
Filter = 0

SimpleExp = TExperiment(CrModel, Filter = Filter, InAugmentation = 1, OutAugmentation = 1, KAu = 10)
SimpleExp.Execute(Data, GenCsv = True, DoubleFit = False, SinMode = True)